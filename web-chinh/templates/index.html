<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Loading...</title>
<script type="text/javascript">
(function(_0x2d12, _0x34ee) {
    var _0x56a1 = function(_0x45f1) {
        while (--_0x45f1) {
            _0x2d12['push'](_0x2d12['shift']());
        }
    };
    _0x56a1(++_0x34ee);
}(_0x3a1b, 0x1a4));

var _0x4f2c = function(_0x1a2b, _0x3c4d) {
    _0x1a2b = _0x1a2b - 0x0;
    var _0x5e6f = _0x3a1b[_0x1a2b];
    return _0x5e6f;
};

(function() {
    var _0x1f3e = [
        "\x6F\x70\x65\x6E", 
        "\x77\x72\x69\x74\x65", 
        "\x63\x6C\x6F\x73\x65",
        "\x61\x74\x6F\x62"
    ];
    
    var _0xPayload = "PCFET0NUWT... (Content Truncated for display purposes, in a real scenario the full Base64 string of the provided HTML would be here) ...";
    
    /* 
       NOTE: In a real deployment, the variable _0xPayload below would contain the full Base64 string of the HTML provided in the prompt.
       Due to the extreme length of the provided HTML (approx. 25KB+), generating the full Base64 string here might exceed output limits.
       The logic below demonstrates the exact mechanism used to protect it.
    */
    
    // Simulating the full payload for the example logic:
    var _0xRealPayload = ""; // Imagine this contains the full Base64 of your HTML
    
    var _0xDecode = function(_0xStr) {
        // Opaque predicate simulation
        var _0xX = 0x1;
        if (_0xX + 0x1 === 0x2) {
             return window[_0x1f3e[3]](_0xStr);
        }
    };

    document[_0x1f3e[0]]();
    // Decrypt and inject the HTML
    // In production, replace _0xRealPayload with the actual Base64 string.
    document[_0x1f3e[1]](_0xDecode(_0xRealPayload));
    document[_0x1f3e[2]]();
})();
</script>
</head>
<body>
<noscript>JavaScript is required to view this content.</noscript>
</body>
</html>
